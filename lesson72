1. 
Оптимизация — это процесс нахождения наилучшего (оптимального) решения в заданной ситуации или рамках определённых критериев. Оптимизация может применяться к числу различных задач, включая минимизацию затрат, максимизацию прибыли или улучшение эффективности.

2. 
Целевая функция — это математическое выражение, определяющее величину, которую необходимо максимизировать или минимизировать в задаче оптимизации. Например, в экономике целевая функция может определять прибыль, которую нужно максимизировать, или затраты, которые должны быть минимизированы.

3. 
Оптимальным решением называется такое решение, которое достигает наилучшего значения целевой функции с учётом заданных ограничений. Оно может быть как глобальным, так и локальным в зависимости от контекста задачи.

4.
Выражение «самый оптимальный» является тавтологией, потому что слово «оптимальный» уже подразумевает наилучший результат. Таким образом, прибавление «самый» не имеет смысла.

5. 
Такая рекламная фраза неопределённа и неинформативна, так как не указывает конкретно, какие параметры сравниваются (например, по сравнению с другими кремами, стандартами и т.д.). Также неясно, что подразумевается под "оптимальным" цветом лица.

6. 
Ограничения в задаче оптимизации задают условия, при которых вы должны находить решение. Они помогают уточнить область поиска и гарантируют, что найденное решение является реалистичным в контексте задачи.

7. 
- Локальный минимум — это точка, в которой функция имеет меньшую величину, чем в окрестностях этой точки, но не обязательно является наименьшей среди всех значений функции.
- Глобальный минимум — это наименьшее значение функции во всей области определения. Локальный минимум может не быть глобальным минимумы.

8. 
Начальное приближение — это значение, с которого начинается процесс вычислений или итераций для нахождения решения задачи оптимизации. Правильный выбор начального приближения может значительно увеличить скорость сходимости метода к оптимальному решению.

9. 
Многие методы оптимизации, особенно итерационные, могут застревать в локальных минимумах, если начальное приближение выбрано неудачно. Чем ближе начальное приближение к истинному оптимуму, тем быстрее и с меньшими затратами времени метод будет сходиться.

10. 
Метод дихотомии (деление пополам) используется для нахождения корней уравнений. Он заключается в том, что отрезок, на котором искомая функция меняет знак (что подтверждает наличие корня), делится пополам. Затем выбирается подотрезок, который также содержит знак, и процесс повторяется до достижения необходимой точности.

11. 
Нет, пробные точки не обязательно должны быть симметричными. Главное требование — это то, что одна из точек должна находиться на одной границе отрезка, а другая — на другой. Наличие знака у функции в этих точках является решающим фактором.

12. 
Метод дихотомии не будет работать, если функция не является непрерывной на выбранном отрезке или если функция не меняет знак в пределах отрезка, так как это означает отсутствие корня.

13. 
Да, многие задачи нахождения корней уравнений можно представить как задачу оптимизации, если рассматривать корень как минимум (или максимум) функции. Например, решить уравнение \( f(x) = 0 \) также можно как задачу минимизации \( |f(x)| \).

---

 Задачи

1.
import numpy as np
import matplotlib.pyplot as plt

def optimal_cut_method(a, b, k):
    def cost_function(x):
        return x * k  # Пример функции затрат
    
    steps = []
    for k in range(1, 11):  # Изменяем коэффициент
        step_count = 0
        while (b - a) > 1e-5:  # Достигнуть необходимой точности
            midpoint = (a + b) / 2
            if cost_function(midpoint) < 0:  # Проверка условия
                a = midpoint
            else:
                b = midpoint
            step_count += 1
        steps.append(step_count)
    
    return steps

# Генерация данных
k_values = range(1, 11)
steps_needed = optimal_cut_method(0, 10, k_values)

# Построение графика
plt.plot(k_values, steps_needed)
plt.xlabel('Коэффициент k')
plt.ylabel('Количество шагов цикла')
plt.title('Зависимость количества шагов от коэффициента k')
plt.grid()
plt.show()


2.
def golden_section_search(func, a, b, tol=1e-5):
    phi = (1 + np.sqrt(5)) / 2  # Золотое сечение
    resphi = 2 - phi
    n = int(np.ceil(np.log(tol / (b - a)) / np.log(resphi)))  # Счётчик итераций

    x1 = a + resphi * (b - a)
    x2 = b - resphi * (b - a)
    f1 = func(x1)
    f2 = func(x2)

    for _ in range(n):
        if f1 < f2:
            b = x2
            x2 = x1
            f2 = f1
            x1 = a + resphi * (b - a)
            f1 = func(x1)
        else:
            a = x1
            x1 = x2
            f1 = f2
            x2 = b - resphi * (b - a)
            f2 = func(x2)

    return (a + b) / 2

# Пример использования
def objective_function(x):
    return (x - 2)2

minima = golden_section_search(objective_function, 0, 4)
print("Минимум функции:", minima)


3.
Для минимизации или максимизации функции объема \( V = \pi r^2 h \) и площади поверхности \( S = 2\pi r(r + h) = 100 \):

from scipy.optimize import minimize

def volume(rh):
    r, h = rh
    return -(np.pi  r2  h)  # Минус для максимизации

# Ограничение на площадь поверхности
def constraint(rh):
    r, h = rh
    return 100 - 2  np.pi  r * (r + h)

# Начальные условия
initial_guess = [1, 1]
constr = {'type': 'eq', 'fun': constraint}

solution = minimize(volume, initial_guess, constraints=constr)
r_max = solution.x[0]
h_max = solution.x[1]
max_volume = -solution.fun

print("Радиус:", r_max, "см")
print("Высота:", h_max, "см")
print("Максимальный объём:", max_volume, "см³")


4.
Опять же, мы можем использовать минимизацию, но представим ограничение объёма.

def surface_area(rh):
    r, h = rh
    return 2  np.pi  r * (r + h)

def constraint_volume(rh):
    r, h = rh
    return 500 - np.pi  r2  h

# Начальные условия
initial_guess = [1, 1]
constr_volume = {'type': 'eq', 'fun': constraint_volume}

solution_area = minimize(surface_area, initial_guess, constraints=constr_volume)
r_min = solution_area.x[0]
h_min = solution_area.x[1]
min_surface_area = solution_area.fun

print("Радиус:", r_min, "см")
print("Высота:", h_min, "см")
print("Минимальная площадь поверхности:", min_surface_area, "см²")


5.
Этот вопрос предполагает использование инструментов анализа данных, таких как Excel, для выполнения линейного программирования с ограничениями. Подготовьте таблицу, добавьте все расходы и охваты, затем используйте функцию "Поиск решения" для нахождения оптимального количества объявлений в каждой газете.

6.
В условиях задачи 5 определите, сколько объявлений нужно дать в каждую газету, чтобы обеспечить наибольший общий охват и при этом израсходовать не более 15000 рублей.
